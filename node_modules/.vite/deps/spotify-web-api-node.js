import {
  __commonJS
} from "./chunk-NISBT54A.js";

// node_modules/spotify-web-api-node/src/base-request.js
var require_base_request = __commonJS({
  "node_modules/spotify-web-api-node/src/base-request.js"(exports, module) {
    "use strict";
    var Request = function(builder) {
      if (!builder) {
        throw new Error("No builder supplied to constructor");
      }
      this.host = builder.host;
      this.port = builder.port;
      this.scheme = builder.scheme;
      this.queryParameters = builder.queryParameters;
      this.bodyParameters = builder.bodyParameters;
      this.headers = builder.headers;
      this.path = builder.path;
    };
    Request.prototype._getter = function(key) {
      return function() {
        return this[key];
      };
    };
    Request.prototype.getHost = Request.prototype._getter("host");
    Request.prototype.getPort = Request.prototype._getter("port");
    Request.prototype.getScheme = Request.prototype._getter("scheme");
    Request.prototype.getPath = Request.prototype._getter("path");
    Request.prototype.getQueryParameters = Request.prototype._getter("queryParameters");
    Request.prototype.getBodyParameters = Request.prototype._getter("bodyParameters");
    Request.prototype.getHeaders = Request.prototype._getter("headers");
    Request.prototype.getURI = function() {
      if (!this.scheme || !this.host || !this.port) {
        throw new Error("Missing components necessary to construct URI");
      }
      var uri = this.scheme + "://" + this.host;
      if (this.scheme === "http" && this.port !== 80 || this.scheme === "https" && this.port !== 443) {
        uri += ":" + this.port;
      }
      if (this.path) {
        uri += this.path;
      }
      return uri;
    };
    Request.prototype.getURL = function() {
      var uri = this.getURI();
      if (this.getQueryParameters()) {
        return uri + this.getQueryParameterString(this.getQueryParameters());
      } else {
        return uri;
      }
    };
    Request.prototype.getQueryParameterString = function() {
      var queryParameters = this.getQueryParameters();
      if (queryParameters) {
        return "?" + Object.keys(queryParameters).filter(function(key) {
          return queryParameters[key] !== void 0;
        }).map(function(key) {
          return key + "=" + queryParameters[key];
        }).join("&");
      }
    };
    Request.prototype.execute = function(method, callback) {
      if (callback) {
        method(this, callback);
        return;
      }
      var _self = this;
      return new Promise(function(resolve, reject) {
        method(_self, function(error, result) {
          if (error) {
            reject(error);
          } else {
            resolve(result);
          }
        });
      });
    };
    var Builder = function() {
    };
    Builder.prototype._setter = function(key) {
      return function(value) {
        this[key] = value;
        return this;
      };
    };
    Builder.prototype.withHost = Builder.prototype._setter("host");
    Builder.prototype.withPort = Builder.prototype._setter("port");
    Builder.prototype.withScheme = Builder.prototype._setter("scheme");
    Builder.prototype.withPath = Builder.prototype._setter("path");
    Builder.prototype._assigner = function(key) {
      return function() {
        for (var i = 0; i < arguments.length; i++) {
          this[key] = this._assign(this[key], arguments[i]);
        }
        return this;
      };
    };
    Builder.prototype.withQueryParameters = Builder.prototype._assigner("queryParameters");
    Builder.prototype.withBodyParameters = Builder.prototype._assigner("bodyParameters");
    Builder.prototype.withHeaders = Builder.prototype._assigner("headers");
    Builder.prototype.withAuth = function(accessToken) {
      if (accessToken) {
        this.withHeaders({ Authorization: "Bearer " + accessToken });
      }
      return this;
    };
    Builder.prototype._assign = function(src, obj) {
      if (obj && Array.isArray(obj)) {
        return obj;
      }
      if (obj && typeof obj === "string") {
        return obj;
      }
      if (obj && Object.keys(obj).length > 0) {
        return Object.assign(src || {}, obj);
      }
      return src;
    };
    Builder.prototype.build = function() {
      return new Request(this);
    };
    module.exports.builder = function() {
      return new Builder();
    };
  }
});

// node_modules/spotify-web-api-node/src/authentication-request.js
var require_authentication_request = __commonJS({
  "node_modules/spotify-web-api-node/src/authentication-request.js"(exports, module) {
    "use strict";
    var Request = require_base_request();
    var DEFAULT_HOST = "accounts.spotify.com";
    var DEFAULT_PORT = 443;
    var DEFAULT_SCHEME = "https";
    module.exports.builder = function() {
      return Request.builder().withHost(DEFAULT_HOST).withPort(DEFAULT_PORT).withScheme(DEFAULT_SCHEME);
    };
  }
});

// node_modules/spotify-web-api-node/src/webapi-request.js
var require_webapi_request = __commonJS({
  "node_modules/spotify-web-api-node/src/webapi-request.js"(exports, module) {
    "use strict";
    var Request = require_base_request();
    var DEFAULT_HOST = "api.spotify.com";
    var DEFAULT_PORT = 443;
    var DEFAULT_SCHEME = "https";
    module.exports.builder = function(accessToken) {
      return Request.builder().withHost(DEFAULT_HOST).withPort(DEFAULT_PORT).withScheme(DEFAULT_SCHEME).withAuth(accessToken);
    };
  }
});

// node_modules/component-emitter/index.js
var require_component_emitter = __commonJS({
  "node_modules/component-emitter/index.js"(exports, module) {
    if (typeof module !== "undefined") {
      module.exports = Emitter;
    }
    function Emitter(obj) {
      if (obj)
        return mixin(obj);
    }
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (arguments.length == 0) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks["$" + event];
      if (!callbacks)
        return this;
      if (arguments.length == 1) {
        delete this._callbacks["$" + event];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      if (callbacks.length === 0) {
        delete this._callbacks["$" + event];
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks["$" + event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports, module) {
    module.exports = stringify;
    stringify.default = stringify;
    stringify.stable = deterministicStringify;
    stringify.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace]);
        }
      } else {
        parent[k] = replace;
        arr.push([parent, k, val]);
      }
    }
    function decirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            decirc(val[key], key, i, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            deterministicDecirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            deterministicDecirc(val[key], key, i, stack, val, depth, options);
            tmp[key] = val[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
        return v;
      };
      return function(key, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(this, args.concat(slice.call(arguments)));
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(that, args.concat(slice.call(arguments)));
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src = __commonJS({
  "node_modules/has/src/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x) {
      return x.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(func, "length", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports, module) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
        });
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
          out += string.charAt(i);
          continue;
        }
        if (c < 128) {
          out = out + hexTable[c];
          continue;
        }
        if (c < 2048) {
          out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
          continue;
        }
        if (c < 55296 || c >= 57344) {
          out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var split = String.prototype.split;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          if (generateArrayPrefix === "comma" && encodeValuesOnly) {
            var valuesArray = split.call(String(obj), ",");
            var valuesJoined = "";
            for (var i = 0; i < valuesArray.length; ++i) {
              valuesJoined += (i === 0 ? "" : ",") + formatter(encoder(valuesArray[i], defaults.encoder, charset, "value", format));
            }
            return [formatter(keyValue) + (commaRoundTrip && isArray(obj) && valuesArray.length === 1 ? "[]" : "") + "=" + valuesJoined];
          }
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + "[]" : prefix;
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(value, keyPrefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, commaRoundTrip, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
            return options.decoder(encodedVal, defaults.decoder, charset, "value");
          });
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        if (has.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    var stringify = require_stringify();
    var parse = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse,
      stringify
    };
  }
});

// node_modules/superagent/lib/is-object.js
var require_is_object = __commonJS({
  "node_modules/superagent/lib/is-object.js"(exports, module) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function isObject(obj) {
      return obj !== null && _typeof(obj) === "object";
    }
    module.exports = isObject;
  }
});

// node_modules/superagent/lib/request-base.js
var require_request_base = __commonJS({
  "node_modules/superagent/lib/request-base.js"(exports, module) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var isObject = require_is_object();
    module.exports = RequestBase;
    function RequestBase(object) {
      if (object)
        return mixin(object);
    }
    function mixin(object) {
      for (var key in RequestBase.prototype) {
        if (Object.prototype.hasOwnProperty.call(RequestBase.prototype, key))
          object[key] = RequestBase.prototype[key];
      }
      return object;
    }
    RequestBase.prototype.clearTimeout = function() {
      clearTimeout(this._timer);
      clearTimeout(this._responseTimeoutTimer);
      clearTimeout(this._uploadTimeoutTimer);
      delete this._timer;
      delete this._responseTimeoutTimer;
      delete this._uploadTimeoutTimer;
      return this;
    };
    RequestBase.prototype.parse = function(fn) {
      this._parser = fn;
      return this;
    };
    RequestBase.prototype.responseType = function(value) {
      this._responseType = value;
      return this;
    };
    RequestBase.prototype.serialize = function(fn) {
      this._serializer = fn;
      return this;
    };
    RequestBase.prototype.timeout = function(options) {
      if (!options || _typeof(options) !== "object") {
        this._timeout = options;
        this._responseTimeout = 0;
        this._uploadTimeout = 0;
        return this;
      }
      for (var option in options) {
        if (Object.prototype.hasOwnProperty.call(options, option)) {
          switch (option) {
            case "deadline":
              this._timeout = options.deadline;
              break;
            case "response":
              this._responseTimeout = options.response;
              break;
            case "upload":
              this._uploadTimeout = options.upload;
              break;
            default:
              console.warn("Unknown timeout option", option);
          }
        }
      }
      return this;
    };
    RequestBase.prototype.retry = function(count, fn) {
      if (arguments.length === 0 || count === true)
        count = 1;
      if (count <= 0)
        count = 0;
      this._maxRetries = count;
      this._retries = 0;
      this._retryCallback = fn;
      return this;
    };
    var ERROR_CODES = /* @__PURE__ */ new Set(["ETIMEDOUT", "ECONNRESET", "EADDRINUSE", "ECONNREFUSED", "EPIPE", "ENOTFOUND", "ENETUNREACH", "EAI_AGAIN"]);
    var STATUS_CODES = /* @__PURE__ */ new Set([408, 413, 429, 500, 502, 503, 504, 521, 522, 524]);
    RequestBase.prototype._shouldRetry = function(err, res) {
      if (!this._maxRetries || this._retries++ >= this._maxRetries) {
        return false;
      }
      if (this._retryCallback) {
        try {
          var override = this._retryCallback(err, res);
          if (override === true)
            return true;
          if (override === false)
            return false;
        } catch (err_) {
          console.error(err_);
        }
      }
      if (res && res.status && STATUS_CODES.has(res.status))
        return true;
      if (err) {
        if (err.code && ERROR_CODES.has(err.code))
          return true;
        if (err.timeout && err.code === "ECONNABORTED")
          return true;
        if (err.crossDomain)
          return true;
      }
      return false;
    };
    RequestBase.prototype._retry = function() {
      this.clearTimeout();
      if (this.req) {
        this.req = null;
        this.req = this.request();
      }
      this._aborted = false;
      this.timedout = false;
      this.timedoutError = null;
      return this._end();
    };
    RequestBase.prototype.then = function(resolve, reject) {
      var _this = this;
      if (!this._fullfilledPromise) {
        var self2 = this;
        if (this._endCalled) {
          console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
        }
        this._fullfilledPromise = new Promise(function(resolve2, reject2) {
          self2.on("abort", function() {
            if (_this._maxRetries && _this._maxRetries > _this._retries) {
              return;
            }
            if (_this.timedout && _this.timedoutError) {
              reject2(_this.timedoutError);
              return;
            }
            var err = new Error("Aborted");
            err.code = "ABORTED";
            err.status = _this.status;
            err.method = _this.method;
            err.url = _this.url;
            reject2(err);
          });
          self2.end(function(err, res) {
            if (err)
              reject2(err);
            else
              resolve2(res);
          });
        });
      }
      return this._fullfilledPromise.then(resolve, reject);
    };
    RequestBase.prototype.catch = function(cb) {
      return this.then(void 0, cb);
    };
    RequestBase.prototype.use = function(fn) {
      fn(this);
      return this;
    };
    RequestBase.prototype.ok = function(cb) {
      if (typeof cb !== "function")
        throw new Error("Callback required");
      this._okCallback = cb;
      return this;
    };
    RequestBase.prototype._isResponseOK = function(res) {
      if (!res) {
        return false;
      }
      if (this._okCallback) {
        return this._okCallback(res);
      }
      return res.status >= 200 && res.status < 300;
    };
    RequestBase.prototype.get = function(field) {
      return this._header[field.toLowerCase()];
    };
    RequestBase.prototype.getHeader = RequestBase.prototype.get;
    RequestBase.prototype.set = function(field, value) {
      if (isObject(field)) {
        for (var key in field) {
          if (Object.prototype.hasOwnProperty.call(field, key))
            this.set(key, field[key]);
        }
        return this;
      }
      this._header[field.toLowerCase()] = value;
      this.header[field] = value;
      return this;
    };
    RequestBase.prototype.unset = function(field) {
      delete this._header[field.toLowerCase()];
      delete this.header[field];
      return this;
    };
    RequestBase.prototype.field = function(name, value) {
      if (name === null || name === void 0) {
        throw new Error(".field(name, val) name can not be empty");
      }
      if (this._data) {
        throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
      }
      if (isObject(name)) {
        for (var key in name) {
          if (Object.prototype.hasOwnProperty.call(name, key))
            this.field(key, name[key]);
        }
        return this;
      }
      if (Array.isArray(value)) {
        for (var i in value) {
          if (Object.prototype.hasOwnProperty.call(value, i))
            this.field(name, value[i]);
        }
        return this;
      }
      if (value === null || value === void 0) {
        throw new Error(".field(name, val) val can not be empty");
      }
      if (typeof value === "boolean") {
        value = String(value);
      }
      this._getFormData().append(name, value);
      return this;
    };
    RequestBase.prototype.abort = function() {
      if (this._aborted) {
        return this;
      }
      this._aborted = true;
      if (this.xhr)
        this.xhr.abort();
      if (this.req)
        this.req.abort();
      this.clearTimeout();
      this.emit("abort");
      return this;
    };
    RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
      switch (options.type) {
        case "basic":
          this.set("Authorization", "Basic ".concat(base64Encoder("".concat(user, ":").concat(pass))));
          break;
        case "auto":
          this.username = user;
          this.password = pass;
          break;
        case "bearer":
          this.set("Authorization", "Bearer ".concat(user));
          break;
        default:
          break;
      }
      return this;
    };
    RequestBase.prototype.withCredentials = function(on) {
      if (on === void 0)
        on = true;
      this._withCredentials = on;
      return this;
    };
    RequestBase.prototype.redirects = function(n) {
      this._maxRedirects = n;
      return this;
    };
    RequestBase.prototype.maxResponseSize = function(n) {
      if (typeof n !== "number") {
        throw new TypeError("Invalid argument");
      }
      this._maxResponseSize = n;
      return this;
    };
    RequestBase.prototype.toJSON = function() {
      return {
        method: this.method,
        url: this.url,
        data: this._data,
        headers: this._header
      };
    };
    RequestBase.prototype.send = function(data) {
      var isObject_ = isObject(data);
      var type = this._header["content-type"];
      if (this._formData) {
        throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
      }
      if (isObject_ && !this._data) {
        if (Array.isArray(data)) {
          this._data = [];
        } else if (!this._isHost(data)) {
          this._data = {};
        }
      } else if (data && this._data && this._isHost(this._data)) {
        throw new Error("Can't merge these send calls");
      }
      if (isObject_ && isObject(this._data)) {
        for (var key in data) {
          if (Object.prototype.hasOwnProperty.call(data, key))
            this._data[key] = data[key];
        }
      } else if (typeof data === "string") {
        if (!type)
          this.type("form");
        type = this._header["content-type"];
        if (type)
          type = type.toLowerCase().trim();
        if (type === "application/x-www-form-urlencoded") {
          this._data = this._data ? "".concat(this._data, "&").concat(data) : data;
        } else {
          this._data = (this._data || "") + data;
        }
      } else {
        this._data = data;
      }
      if (!isObject_ || this._isHost(data)) {
        return this;
      }
      if (!type)
        this.type("json");
      return this;
    };
    RequestBase.prototype.sortQuery = function(sort) {
      this._sort = typeof sort === "undefined" ? true : sort;
      return this;
    };
    RequestBase.prototype._finalizeQueryString = function() {
      var query = this._query.join("&");
      if (query) {
        this.url += (this.url.includes("?") ? "&" : "?") + query;
      }
      this._query.length = 0;
      if (this._sort) {
        var index = this.url.indexOf("?");
        if (index >= 0) {
          var queryArray = this.url.slice(index + 1).split("&");
          if (typeof this._sort === "function") {
            queryArray.sort(this._sort);
          } else {
            queryArray.sort();
          }
          this.url = this.url.slice(0, index) + "?" + queryArray.join("&");
        }
      }
    };
    RequestBase.prototype._appendQueryString = function() {
      console.warn("Unsupported");
    };
    RequestBase.prototype._timeoutError = function(reason, timeout, errno) {
      if (this._aborted) {
        return;
      }
      var err = new Error("".concat(reason + timeout, "ms exceeded"));
      err.timeout = timeout;
      err.code = "ECONNABORTED";
      err.errno = errno;
      this.timedout = true;
      this.timedoutError = err;
      this.abort();
      this.callback(err);
    };
    RequestBase.prototype._setTimeouts = function() {
      var self2 = this;
      if (this._timeout && !this._timer) {
        this._timer = setTimeout(function() {
          self2._timeoutError("Timeout of ", self2._timeout, "ETIME");
        }, this._timeout);
      }
      if (this._responseTimeout && !this._responseTimeoutTimer) {
        this._responseTimeoutTimer = setTimeout(function() {
          self2._timeoutError("Response timeout of ", self2._responseTimeout, "ETIMEDOUT");
        }, this._responseTimeout);
      }
    };
  }
});

// node_modules/superagent/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/superagent/lib/utils.js"(exports) {
    "use strict";
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = o[Symbol.iterator]();
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    exports.type = function(str) {
      return str.split(/ *; */).shift();
    };
    exports.params = function(val) {
      var obj = {};
      var _iterator = _createForOfIteratorHelper(val.split(/ *; */)), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var str = _step.value;
          var parts = str.split(/ *= */);
          var key = parts.shift();
          var _val = parts.shift();
          if (key && _val)
            obj[key] = _val;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return obj;
    };
    exports.parseLinks = function(val) {
      var obj = {};
      var _iterator2 = _createForOfIteratorHelper(val.split(/ *, */)), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var str = _step2.value;
          var parts = str.split(/ *; */);
          var url = parts[0].slice(1, -1);
          var rel = parts[1].split(/ *= */)[1].slice(1, -1);
          obj[rel] = url;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return obj;
    };
    exports.cleanHeader = function(header, changesOrigin) {
      delete header["content-type"];
      delete header["content-length"];
      delete header["transfer-encoding"];
      delete header.host;
      if (changesOrigin) {
        delete header.authorization;
        delete header.cookie;
      }
      return header;
    };
  }
});

// node_modules/superagent/lib/response-base.js
var require_response_base = __commonJS({
  "node_modules/superagent/lib/response-base.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = ResponseBase;
    function ResponseBase(obj) {
      if (obj)
        return mixin(obj);
    }
    function mixin(obj) {
      for (var key in ResponseBase.prototype) {
        if (Object.prototype.hasOwnProperty.call(ResponseBase.prototype, key))
          obj[key] = ResponseBase.prototype[key];
      }
      return obj;
    }
    ResponseBase.prototype.get = function(field) {
      return this.header[field.toLowerCase()];
    };
    ResponseBase.prototype._setHeaderProperties = function(header) {
      var ct = header["content-type"] || "";
      this.type = utils.type(ct);
      var params = utils.params(ct);
      for (var key in params) {
        if (Object.prototype.hasOwnProperty.call(params, key))
          this[key] = params[key];
      }
      this.links = {};
      try {
        if (header.link) {
          this.links = utils.parseLinks(header.link);
        }
      } catch (_unused) {
      }
    };
    ResponseBase.prototype._setStatusProperties = function(status) {
      var type = status / 100 | 0;
      this.statusCode = status;
      this.status = this.statusCode;
      this.statusType = type;
      this.info = type === 1;
      this.ok = type === 2;
      this.redirect = type === 3;
      this.clientError = type === 4;
      this.serverError = type === 5;
      this.error = type === 4 || type === 5 ? this.toError() : false;
      this.created = status === 201;
      this.accepted = status === 202;
      this.noContent = status === 204;
      this.badRequest = status === 400;
      this.unauthorized = status === 401;
      this.notAcceptable = status === 406;
      this.forbidden = status === 403;
      this.notFound = status === 404;
      this.unprocessableEntity = status === 422;
    };
  }
});

// node_modules/superagent/lib/agent-base.js
var require_agent_base = __commonJS({
  "node_modules/superagent/lib/agent-base.js"(exports, module) {
    "use strict";
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function Agent() {
      this._defaults = [];
    }
    ["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert", "disableTLSCerts"].forEach(function(fn) {
      Agent.prototype[fn] = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        this._defaults.push({
          fn,
          args
        });
        return this;
      };
    });
    Agent.prototype._setDefaults = function(req) {
      this._defaults.forEach(function(def) {
        req[def.fn].apply(req, _toConsumableArray(def.args));
      });
    };
    module.exports = Agent;
  }
});

// node_modules/superagent/lib/client.js
var require_client = __commonJS({
  "node_modules/superagent/lib/client.js"(exports, module) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var root;
    if (typeof window !== "undefined") {
      root = window;
    } else if (typeof self === "undefined") {
      console.warn("Using browser-only version of superagent in non-browser environment");
      root = void 0;
    } else {
      root = self;
    }
    var Emitter = require_component_emitter();
    var safeStringify = require_fast_safe_stringify();
    var qs = require_lib();
    var RequestBase = require_request_base();
    var isObject = require_is_object();
    var ResponseBase = require_response_base();
    var Agent = require_agent_base();
    function noop() {
    }
    module.exports = function(method, url) {
      if (typeof url === "function") {
        return new exports.Request("GET", method).end(url);
      }
      if (arguments.length === 1) {
        return new exports.Request("GET", method);
      }
      return new exports.Request(method, url);
    };
    exports = module.exports;
    var request = exports;
    exports.Request = Request;
    request.getXHR = function() {
      if (root.XMLHttpRequest && (!root.location || root.location.protocol !== "file:" || !root.ActiveXObject)) {
        return new XMLHttpRequest();
      }
      try {
        return new ActiveXObject("Microsoft.XMLHTTP");
      } catch (_unused) {
      }
      try {
        return new ActiveXObject("Msxml2.XMLHTTP.6.0");
      } catch (_unused2) {
      }
      try {
        return new ActiveXObject("Msxml2.XMLHTTP.3.0");
      } catch (_unused3) {
      }
      try {
        return new ActiveXObject("Msxml2.XMLHTTP");
      } catch (_unused4) {
      }
      throw new Error("Browser-only version of superagent could not find XHR");
    };
    var trim = "".trim ? function(s) {
      return s.trim();
    } : function(s) {
      return s.replace(/(^\s*|\s*$)/g, "");
    };
    function serialize(obj) {
      if (!isObject(obj))
        return obj;
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          pushEncodedKeyValuePair(pairs, key, obj[key]);
      }
      return pairs.join("&");
    }
    function pushEncodedKeyValuePair(pairs, key, val) {
      if (val === void 0)
        return;
      if (val === null) {
        pairs.push(encodeURI(key));
        return;
      }
      if (Array.isArray(val)) {
        val.forEach(function(v) {
          pushEncodedKeyValuePair(pairs, key, v);
        });
      } else if (isObject(val)) {
        for (var subkey in val) {
          if (Object.prototype.hasOwnProperty.call(val, subkey))
            pushEncodedKeyValuePair(pairs, "".concat(key, "[").concat(subkey, "]"), val[subkey]);
        }
      } else {
        pairs.push(encodeURI(key) + "=" + encodeURIComponent(val));
      }
    }
    request.serializeObject = serialize;
    function parseString(str) {
      var obj = {};
      var pairs = str.split("&");
      var pair;
      var pos;
      for (var i = 0, len = pairs.length; i < len; ++i) {
        pair = pairs[i];
        pos = pair.indexOf("=");
        if (pos === -1) {
          obj[decodeURIComponent(pair)] = "";
        } else {
          obj[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1));
        }
      }
      return obj;
    }
    request.parseString = parseString;
    request.types = {
      html: "text/html",
      json: "application/json",
      xml: "text/xml",
      urlencoded: "application/x-www-form-urlencoded",
      form: "application/x-www-form-urlencoded",
      "form-data": "application/x-www-form-urlencoded"
    };
    request.serialize = {
      "application/x-www-form-urlencoded": qs.stringify,
      "application/json": safeStringify
    };
    request.parse = {
      "application/x-www-form-urlencoded": parseString,
      "application/json": JSON.parse
    };
    function parseHeader(str) {
      var lines = str.split(/\r?\n/);
      var fields = {};
      var index;
      var line;
      var field;
      var val;
      for (var i = 0, len = lines.length; i < len; ++i) {
        line = lines[i];
        index = line.indexOf(":");
        if (index === -1) {
          continue;
        }
        field = line.slice(0, index).toLowerCase();
        val = trim(line.slice(index + 1));
        fields[field] = val;
      }
      return fields;
    }
    function isJSON(mime) {
      return /[/+]json($|[^-\w])/i.test(mime);
    }
    function Response(req) {
      this.req = req;
      this.xhr = this.req.xhr;
      this.text = this.req.method !== "HEAD" && (this.xhr.responseType === "" || this.xhr.responseType === "text") || typeof this.xhr.responseType === "undefined" ? this.xhr.responseText : null;
      this.statusText = this.req.xhr.statusText;
      var status = this.xhr.status;
      if (status === 1223) {
        status = 204;
      }
      this._setStatusProperties(status);
      this.headers = parseHeader(this.xhr.getAllResponseHeaders());
      this.header = this.headers;
      this.header["content-type"] = this.xhr.getResponseHeader("content-type");
      this._setHeaderProperties(this.header);
      if (this.text === null && req._responseType) {
        this.body = this.xhr.response;
      } else {
        this.body = this.req.method === "HEAD" ? null : this._parseBody(this.text ? this.text : this.xhr.response);
      }
    }
    ResponseBase(Response.prototype);
    Response.prototype._parseBody = function(str) {
      var parse = request.parse[this.type];
      if (this.req._parser) {
        return this.req._parser(this, str);
      }
      if (!parse && isJSON(this.type)) {
        parse = request.parse["application/json"];
      }
      return parse && str && (str.length > 0 || str instanceof Object) ? parse(str) : null;
    };
    Response.prototype.toError = function() {
      var req = this.req;
      var method = req.method;
      var url = req.url;
      var msg = "cannot ".concat(method, " ").concat(url, " (").concat(this.status, ")");
      var err = new Error(msg);
      err.status = this.status;
      err.method = method;
      err.url = url;
      return err;
    };
    request.Response = Response;
    function Request(method, url) {
      var self2 = this;
      this._query = this._query || [];
      this.method = method;
      this.url = url;
      this.header = {};
      this._header = {};
      this.on("end", function() {
        var err = null;
        var res = null;
        try {
          res = new Response(self2);
        } catch (err_) {
          err = new Error("Parser is unable to parse the response");
          err.parse = true;
          err.original = err_;
          if (self2.xhr) {
            err.rawResponse = typeof self2.xhr.responseType === "undefined" ? self2.xhr.responseText : self2.xhr.response;
            err.status = self2.xhr.status ? self2.xhr.status : null;
            err.statusCode = err.status;
          } else {
            err.rawResponse = null;
            err.status = null;
          }
          return self2.callback(err);
        }
        self2.emit("response", res);
        var new_err;
        try {
          if (!self2._isResponseOK(res)) {
            new_err = new Error(res.statusText || res.text || "Unsuccessful HTTP response");
          }
        } catch (err_) {
          new_err = err_;
        }
        if (new_err) {
          new_err.original = err;
          new_err.response = res;
          new_err.status = res.status;
          self2.callback(new_err, res);
        } else {
          self2.callback(null, res);
        }
      });
    }
    Emitter(Request.prototype);
    RequestBase(Request.prototype);
    Request.prototype.type = function(type) {
      this.set("Content-Type", request.types[type] || type);
      return this;
    };
    Request.prototype.accept = function(type) {
      this.set("Accept", request.types[type] || type);
      return this;
    };
    Request.prototype.auth = function(user, pass, options) {
      if (arguments.length === 1)
        pass = "";
      if (_typeof(pass) === "object" && pass !== null) {
        options = pass;
        pass = "";
      }
      if (!options) {
        options = {
          type: typeof btoa === "function" ? "basic" : "auto"
        };
      }
      var encoder = function encoder2(string) {
        if (typeof btoa === "function") {
          return btoa(string);
        }
        throw new Error("Cannot use basic auth, btoa is not a function");
      };
      return this._auth(user, pass, options, encoder);
    };
    Request.prototype.query = function(val) {
      if (typeof val !== "string")
        val = serialize(val);
      if (val)
        this._query.push(val);
      return this;
    };
    Request.prototype.attach = function(field, file, options) {
      if (file) {
        if (this._data) {
          throw new Error("superagent can't mix .send() and .attach()");
        }
        this._getFormData().append(field, file, options || file.name);
      }
      return this;
    };
    Request.prototype._getFormData = function() {
      if (!this._formData) {
        this._formData = new root.FormData();
      }
      return this._formData;
    };
    Request.prototype.callback = function(err, res) {
      if (this._shouldRetry(err, res)) {
        return this._retry();
      }
      var fn = this._callback;
      this.clearTimeout();
      if (err) {
        if (this._maxRetries)
          err.retries = this._retries - 1;
        this.emit("error", err);
      }
      fn(err, res);
    };
    Request.prototype.crossDomainError = function() {
      var err = new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.");
      err.crossDomain = true;
      err.status = this.status;
      err.method = this.method;
      err.url = this.url;
      this.callback(err);
    };
    Request.prototype.agent = function() {
      console.warn("This is not supported in browser version of superagent");
      return this;
    };
    Request.prototype.ca = Request.prototype.agent;
    Request.prototype.buffer = Request.prototype.ca;
    Request.prototype.write = function() {
      throw new Error("Streaming is not supported in browser version of superagent");
    };
    Request.prototype.pipe = Request.prototype.write;
    Request.prototype._isHost = function(obj) {
      return obj && _typeof(obj) === "object" && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== "[object Object]";
    };
    Request.prototype.end = function(fn) {
      if (this._endCalled) {
        console.warn("Warning: .end() was called twice. This is not supported in superagent");
      }
      this._endCalled = true;
      this._callback = fn || noop;
      this._finalizeQueryString();
      this._end();
    };
    Request.prototype._setUploadTimeout = function() {
      var self2 = this;
      if (this._uploadTimeout && !this._uploadTimeoutTimer) {
        this._uploadTimeoutTimer = setTimeout(function() {
          self2._timeoutError("Upload timeout of ", self2._uploadTimeout, "ETIMEDOUT");
        }, this._uploadTimeout);
      }
    };
    Request.prototype._end = function() {
      if (this._aborted)
        return this.callback(new Error("The request has been aborted even before .end() was called"));
      var self2 = this;
      this.xhr = request.getXHR();
      var xhr = this.xhr;
      var data = this._formData || this._data;
      this._setTimeouts();
      xhr.onreadystatechange = function() {
        var readyState = xhr.readyState;
        if (readyState >= 2 && self2._responseTimeoutTimer) {
          clearTimeout(self2._responseTimeoutTimer);
        }
        if (readyState !== 4) {
          return;
        }
        var status;
        try {
          status = xhr.status;
        } catch (_unused5) {
          status = 0;
        }
        if (!status) {
          if (self2.timedout || self2._aborted)
            return;
          return self2.crossDomainError();
        }
        self2.emit("end");
      };
      var handleProgress = function handleProgress2(direction, e) {
        if (e.total > 0) {
          e.percent = e.loaded / e.total * 100;
          if (e.percent === 100) {
            clearTimeout(self2._uploadTimeoutTimer);
          }
        }
        e.direction = direction;
        self2.emit("progress", e);
      };
      if (this.hasListeners("progress")) {
        try {
          xhr.addEventListener("progress", handleProgress.bind(null, "download"));
          if (xhr.upload) {
            xhr.upload.addEventListener("progress", handleProgress.bind(null, "upload"));
          }
        } catch (_unused6) {
        }
      }
      if (xhr.upload) {
        this._setUploadTimeout();
      }
      try {
        if (this.username && this.password) {
          xhr.open(this.method, this.url, true, this.username, this.password);
        } else {
          xhr.open(this.method, this.url, true);
        }
      } catch (err) {
        return this.callback(err);
      }
      if (this._withCredentials)
        xhr.withCredentials = true;
      if (!this._formData && this.method !== "GET" && this.method !== "HEAD" && typeof data !== "string" && !this._isHost(data)) {
        var contentType = this._header["content-type"];
        var _serialize = this._serializer || request.serialize[contentType ? contentType.split(";")[0] : ""];
        if (!_serialize && isJSON(contentType)) {
          _serialize = request.serialize["application/json"];
        }
        if (_serialize)
          data = _serialize(data);
      }
      for (var field in this.header) {
        if (this.header[field] === null)
          continue;
        if (Object.prototype.hasOwnProperty.call(this.header, field))
          xhr.setRequestHeader(field, this.header[field]);
      }
      if (this._responseType) {
        xhr.responseType = this._responseType;
      }
      this.emit("request", this);
      xhr.send(typeof data === "undefined" ? null : data);
    };
    request.agent = function() {
      return new Agent();
    };
    ["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function(method) {
      Agent.prototype[method.toLowerCase()] = function(url, fn) {
        var req = new request.Request(method, url);
        this._setDefaults(req);
        if (fn) {
          req.end(fn);
        }
        return req;
      };
    });
    Agent.prototype.del = Agent.prototype.delete;
    request.get = function(url, data, fn) {
      var req = request("GET", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.query(data);
      if (fn)
        req.end(fn);
      return req;
    };
    request.head = function(url, data, fn) {
      var req = request("HEAD", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.query(data);
      if (fn)
        req.end(fn);
      return req;
    };
    request.options = function(url, data, fn) {
      var req = request("OPTIONS", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.send(data);
      if (fn)
        req.end(fn);
      return req;
    };
    function del(url, data, fn) {
      var req = request("DELETE", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.send(data);
      if (fn)
        req.end(fn);
      return req;
    }
    request.del = del;
    request.delete = del;
    request.patch = function(url, data, fn) {
      var req = request("PATCH", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.send(data);
      if (fn)
        req.end(fn);
      return req;
    };
    request.post = function(url, data, fn) {
      var req = request("POST", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.send(data);
      if (fn)
        req.end(fn);
      return req;
    };
    request.put = function(url, data, fn) {
      var req = request("PUT", url);
      if (typeof data === "function") {
        fn = data;
        data = null;
      }
      if (data)
        req.send(data);
      if (fn)
        req.end(fn);
      return req;
    };
  }
});

// node_modules/spotify-web-api-node/src/response-error.js
var require_response_error = __commonJS({
  "node_modules/spotify-web-api-node/src/response-error.js"(exports, module) {
    var NamedError = class extends Error {
      get name() {
        return this.constructor.name;
      }
    };
    var TimeoutError = class extends NamedError {
      constructor() {
        const message = "A timeout occurred while communicating with Spotify's Web API.";
        super(message);
      }
    };
    var WebapiError = class extends NamedError {
      constructor(body, headers, statusCode, message) {
        super(message);
        this.body = body;
        this.headers = headers;
        this.statusCode = statusCode;
      }
    };
    var WebapiRegularError = class extends WebapiError {
      constructor(body, headers, statusCode) {
        const message = "An error occurred while communicating with Spotify's Web API.\nDetails: " + body.error.message + ".";
        super(body, headers, statusCode, message);
      }
    };
    var WebapiAuthenticationError = class extends WebapiError {
      constructor(body, headers, statusCode) {
        const message = "An authentication error occurred while communicating with Spotify's Web API.\nDetails: " + body.error + (body.error_description ? " " + body.error_description + "." : ".");
        super(body, headers, statusCode, message);
      }
    };
    var WebapiPlayerError = class extends WebapiError {
      constructor(body, headers, statusCode) {
        const message = "An error occurred while communicating with Spotify's Web API.\nDetails: " + body.error.message + (body.error.reason ? " " + body.error.reason + "." : ".");
        super(body, headers, statusCode, message);
      }
    };
    module.exports = { WebapiError, TimeoutError, WebapiRegularError, WebapiAuthenticationError, WebapiPlayerError };
  }
});

// node_modules/spotify-web-api-node/src/http-manager.js
var require_http_manager = __commonJS({
  "node_modules/spotify-web-api-node/src/http-manager.js"(exports, module) {
    "use strict";
    var superagent = require_client();
    var {
      TimeoutError,
      WebapiError,
      WebapiRegularError,
      WebapiAuthenticationError,
      WebapiPlayerError
    } = require_response_error();
    var HttpManager = {};
    var _getParametersFromRequest = function(request) {
      var options = {};
      if (request.getQueryParameters()) {
        options.query = request.getQueryParameters();
      }
      if (request.getHeaders() && request.getHeaders()["Content-Type"] === "application/json") {
        options.data = JSON.stringify(request.getBodyParameters());
      } else if (request.getBodyParameters()) {
        options.data = request.getBodyParameters();
      }
      if (request.getHeaders()) {
        options.headers = request.getHeaders();
      }
      return options;
    };
    var _toError = function(response) {
      if (typeof response.body === "object" && response.body.error && typeof response.body.error === "object" && response.body.error.reason) {
        return new WebapiPlayerError(response.body, response.headers, response.statusCode);
      }
      if (typeof response.body === "object" && response.body.error && typeof response.body.error === "object") {
        return new WebapiRegularError(response.body, response.headers, response.statusCode);
      }
      if (typeof response.body === "object" && response.body.error && typeof response.body.error === "string") {
        return new WebapiAuthenticationError(response.body, response.headers, response.statusCode);
      }
      return new WebapiError(response.body, response.headers, response.statusCode, response.body);
    };
    HttpManager._makeRequest = function(method, options, uri, callback) {
      var req = method.bind(superagent)(uri);
      if (options.query) {
        req.query(options.query);
      }
      if (options.headers) {
        req.set(options.headers);
      }
      if (options.data) {
        req.send(options.data);
      }
      req.end(function(err, response) {
        if (err) {
          if (err.timeout) {
            return callback(new TimeoutError());
          } else if (err.response) {
            return callback(_toError(err.response));
          } else {
            return callback(err);
          }
        }
        return callback(null, {
          body: response.body,
          headers: response.headers,
          statusCode: response.statusCode
        });
      });
    };
    HttpManager.get = function(request, callback) {
      var options = _getParametersFromRequest(request);
      var method = superagent.get;
      HttpManager._makeRequest(method, options, request.getURI(), callback);
    };
    HttpManager.post = function(request, callback) {
      var options = _getParametersFromRequest(request);
      var method = superagent.post;
      HttpManager._makeRequest(method, options, request.getURI(), callback);
    };
    HttpManager.del = function(request, callback) {
      var options = _getParametersFromRequest(request);
      var method = superagent.del;
      HttpManager._makeRequest(method, options, request.getURI(), callback);
    };
    HttpManager.put = function(request, callback) {
      var options = _getParametersFromRequest(request);
      var method = superagent.put;
      HttpManager._makeRequest(method, options, request.getURI(), callback);
    };
    module.exports = HttpManager;
  }
});

// node_modules/spotify-web-api-node/src/spotify-web-api.js
var require_spotify_web_api = __commonJS({
  "node_modules/spotify-web-api-node/src/spotify-web-api.js"(exports, module) {
    "use strict";
    var AuthenticationRequest = require_authentication_request();
    var WebApiRequest = require_webapi_request();
    var HttpManager = require_http_manager();
    function SpotifyWebApi(credentials) {
      this._credentials = credentials || {};
    }
    SpotifyWebApi.prototype = {
      setCredentials: function(credentials) {
        for (var key in credentials) {
          if (credentials.hasOwnProperty(key)) {
            this._credentials[key] = credentials[key];
          }
        }
      },
      getCredentials: function() {
        return this._credentials;
      },
      resetCredentials: function() {
        this._credentials = null;
      },
      setClientId: function(clientId) {
        this._setCredential("clientId", clientId);
      },
      setClientSecret: function(clientSecret) {
        this._setCredential("clientSecret", clientSecret);
      },
      setAccessToken: function(accessToken) {
        this._setCredential("accessToken", accessToken);
      },
      setRefreshToken: function(refreshToken) {
        this._setCredential("refreshToken", refreshToken);
      },
      setRedirectURI: function(redirectUri) {
        this._setCredential("redirectUri", redirectUri);
      },
      getRedirectURI: function() {
        return this._getCredential("redirectUri");
      },
      getClientId: function() {
        return this._getCredential("clientId");
      },
      getClientSecret: function() {
        return this._getCredential("clientSecret");
      },
      getAccessToken: function() {
        return this._getCredential("accessToken");
      },
      getRefreshToken: function() {
        return this._getCredential("refreshToken");
      },
      resetClientId: function() {
        this._resetCredential("clientId");
      },
      resetClientSecret: function() {
        this._resetCredential("clientSecret");
      },
      resetAccessToken: function() {
        this._resetCredential("accessToken");
      },
      resetRefreshToken: function() {
        this._resetCredential("refreshToken");
      },
      resetRedirectURI: function() {
        this._resetCredential("redirectUri");
      },
      _setCredential: function(credentialKey, value) {
        this._credentials = this._credentials || {};
        this._credentials[credentialKey] = value;
      },
      _getCredential: function(credentialKey) {
        if (!this._credentials) {
          return;
        } else {
          return this._credentials[credentialKey];
        }
      },
      _resetCredential: function(credentialKey) {
        if (!this._credentials) {
          return;
        } else {
          this._credentials[credentialKey] = null;
        }
      },
      getTrack: function(trackId, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/tracks/" + trackId).withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      getTracks: function(trackIds, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/tracks").withQueryParameters({
          ids: trackIds.join(",")
        }, options).build().execute(HttpManager.get, callback);
      },
      getAlbum: function(albumId, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/albums/" + albumId).withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      getAlbums: function(albumIds, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/albums").withQueryParameters({
          ids: albumIds.join(",")
        }, options).build().execute(HttpManager.get, callback);
      },
      getArtist: function(artistId, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/artists/" + artistId).build().execute(HttpManager.get, callback);
      },
      getArtists: function(artistIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/artists").withQueryParameters({
          ids: artistIds.join(",")
        }).build().execute(HttpManager.get, callback);
      },
      search: function(query, types, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/search/").withQueryParameters({
          type: types.join(","),
          q: query
        }, options).build().execute(HttpManager.get, callback);
      },
      searchAlbums: function(query, options, callback) {
        return this.search(query, ["album"], options, callback);
      },
      searchArtists: function(query, options, callback) {
        return this.search(query, ["artist"], options, callback);
      },
      searchTracks: function(query, options, callback) {
        return this.search(query, ["track"], options, callback);
      },
      searchPlaylists: function(query, options, callback) {
        return this.search(query, ["playlist"], options, callback);
      },
      getArtistAlbums: function(artistId, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/artists/" + artistId + "/albums").withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      getAlbumTracks: function(albumId, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/albums/" + albumId + "/tracks").withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      getArtistTopTracks: function(artistId, country, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/artists/" + artistId + "/top-tracks").withQueryParameters({
          country
        }).build().execute(HttpManager.get, callback);
      },
      getArtistRelatedArtists: function(artistId, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/artists/" + artistId + "/related-artists").build().execute(HttpManager.get, callback);
      },
      getUser: function(userId, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/users/" + encodeURIComponent(userId)).build().execute(HttpManager.get, callback);
      },
      getMe: function(callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me").build().execute(HttpManager.get, callback);
      },
      getUserPlaylists: function(userId, options, callback) {
        var path;
        if (typeof userId === "string") {
          path = "/v1/users/" + encodeURIComponent(userId) + "/playlists";
        } else if (typeof userId === "object") {
          callback = options;
          options = userId;
          path = "/v1/me/playlists";
        } else {
          path = "/v1/me/playlists";
        }
        return WebApiRequest.builder(this.getAccessToken()).withPath(path).withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      getPlaylist: function(playlistId, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/playlists/" + playlistId).withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      getPlaylistTracks: function(playlistId, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/playlists/" + playlistId + "/tracks").withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      createPlaylist: function(name, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/playlists").withHeaders({ "Content-Type": "application/json" }).withBodyParameters({
          name
        }, options).build().execute(HttpManager.post, callback);
      },
      followPlaylist: function(playlistId, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/playlists/" + playlistId + "/followers").withHeaders({ "Content-Type": "application/json" }).withBodyParameters(options).build().execute(HttpManager.put, callback);
      },
      unfollowPlaylist: function(playlistId, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/playlists/" + playlistId + "/followers").build().execute(HttpManager.del, callback);
      },
      changePlaylistDetails: function(playlistId, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/playlists/" + playlistId).withHeaders({ "Content-Type": "application/json" }).withBodyParameters(options).build().execute(HttpManager.put, callback);
      },
      uploadCustomPlaylistCoverImage: function(playlistId, base64URI, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/playlists/" + playlistId + "/images").withHeaders({ "Content-Type": "image/jpeg" }).withBodyParameters(base64URI).build().execute(HttpManager.put, callback);
      },
      addTracksToPlaylist: function(playlistId, tracks, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/playlists/" + playlistId + "/tracks").withHeaders({ "Content-Type": "application/json" }).withQueryParameters(options).withBodyParameters({
          uris: tracks
        }).build().execute(HttpManager.post, callback);
      },
      removeTracksFromPlaylist: function(playlistId, tracks, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/playlists/" + playlistId + "/tracks").withHeaders({ "Content-Type": "application/json" }).withBodyParameters({
          tracks
        }, options).build().execute(HttpManager.del, callback);
      },
      removeTracksFromPlaylistByPosition: function(playlistId, positions, snapshotId, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/playlists/" + playlistId + "/tracks").withHeaders({ "Content-Type": "application/json" }).withBodyParameters({
          positions,
          snapshot_id: snapshotId
        }).build().execute(HttpManager.del, callback);
      },
      replaceTracksInPlaylist: function(playlistId, uris, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/playlists/" + playlistId + "/tracks").withHeaders({ "Content-Type": "application/json" }).withBodyParameters({
          uris
        }).build().execute(HttpManager.put, callback);
      },
      reorderTracksInPlaylist: function(playlistId, rangeStart, insertBefore, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/playlists/" + playlistId + "/tracks").withHeaders({ "Content-Type": "application/json" }).withBodyParameters({
          range_start: rangeStart,
          insert_before: insertBefore
        }, options).build().execute(HttpManager.put, callback);
      },
      getAudioFeaturesForTrack: function(trackId, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/audio-features/" + trackId).build().execute(HttpManager.get, callback);
      },
      getAudioAnalysisForTrack: function(trackId, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/audio-analysis/" + trackId).build().execute(HttpManager.get, callback);
      },
      getAudioFeaturesForTracks: function(trackIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/audio-features").withQueryParameters({
          ids: trackIds.join(",")
        }).build().execute(HttpManager.get, callback);
      },
      getRecommendations: function(options, callback) {
        var _opts = {};
        var optionsOfTypeArray = ["seed_artists", "seed_genres", "seed_tracks"];
        for (var option in options) {
          if (options.hasOwnProperty(option)) {
            if (optionsOfTypeArray.indexOf(option) !== -1 && Object.prototype.toString.call(options[option]) === "[object Array]") {
              _opts[option] = options[option].join(",");
            } else {
              _opts[option] = options[option];
            }
          }
        }
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/recommendations").withQueryParameters(_opts).build().execute(HttpManager.get, callback);
      },
      getAvailableGenreSeeds: function(callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/recommendations/available-genre-seeds").build().execute(HttpManager.get, callback);
      },
      getMySavedTracks: function(options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/tracks").withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      containsMySavedTracks: function(trackIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/tracks/contains").withQueryParameters({
          ids: trackIds.join(",")
        }).build().execute(HttpManager.get, callback);
      },
      removeFromMySavedTracks: function(trackIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/tracks").withHeaders({ "Content-Type": "application/json" }).withBodyParameters({ ids: trackIds }).build().execute(HttpManager.del, callback);
      },
      addToMySavedTracks: function(trackIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/tracks").withHeaders({ "Content-Type": "application/json" }).withBodyParameters({ ids: trackIds }).build().execute(HttpManager.put, callback);
      },
      removeFromMySavedAlbums: function(albumIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/albums").withHeaders({ "Content-Type": "application/json" }).withBodyParameters(albumIds).build().execute(HttpManager.del, callback);
      },
      addToMySavedAlbums: function(albumIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/albums").withHeaders({ "Content-Type": "application/json" }).withBodyParameters(albumIds).build().execute(HttpManager.put, callback);
      },
      getMySavedAlbums: function(options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/albums").withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      containsMySavedAlbums: function(albumIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/albums/contains").withQueryParameters({
          ids: albumIds.join(",")
        }).build().execute(HttpManager.get, callback);
      },
      getMyTopArtists: function(options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/top/artists").withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      getMyTopTracks: function(options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/top/tracks").withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      getMyRecentlyPlayedTracks: function(options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/player/recently-played").withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      addToQueue: function(uri, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/player/queue").withQueryParameters({
          uri
        }, options).build().execute(HttpManager.post, callback);
      },
      getMyDevices: function(callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/player/devices").build().execute(HttpManager.get, callback);
      },
      getMyCurrentPlayingTrack: function(options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/player/currently-playing").withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      getMyCurrentPlaybackState: function(options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/player").withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      transferMyPlayback: function(deviceIds, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/player").withHeaders({ "Content-Type": "application/json" }).withBodyParameters({
          device_ids: deviceIds
        }, options).build().execute(HttpManager.put, callback);
      },
      play: function(options, callback) {
        var _options = options || {};
        var queryParams = _options.device_id ? { device_id: _options.device_id } : null;
        var postData = {};
        ["context_uri", "uris", "offset", "position_ms"].forEach(function(field) {
          if (field in _options) {
            postData[field] = _options[field];
          }
        });
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/player/play").withQueryParameters(queryParams).withHeaders({ "Content-Type": "application/json" }).withBodyParameters(postData).build().execute(HttpManager.put, callback);
      },
      pause: function(options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/player/pause").withQueryParameters(options && options.device_id ? { device_id: options.device_id } : null).withHeaders({ "Content-Type": "application/json" }).build().execute(HttpManager.put, callback);
      },
      skipToPrevious: function(options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/player/previous").withQueryParameters(options && options.device_id ? { device_id: options.device_id } : null).build().execute(HttpManager.post, callback);
      },
      skipToNext: function(options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/player/next").withQueryParameters(options && options.device_id ? { device_id: options.device_id } : null).build().execute(HttpManager.post, callback);
      },
      seek: function(positionMs, options, callback) {
        var params = {
          position_ms: positionMs
        };
        if (options && "device_id" in options) {
          params.device_id = options.device_id;
        }
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/player/seek").withQueryParameters(params).build().execute(HttpManager.put, callback);
      },
      setRepeat: function(state, options, callback) {
        var params = {
          state
        };
        if (options && "device_id" in options) {
          params.device_id = options.device_id;
        }
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/player/repeat").withQueryParameters(params).build().execute(HttpManager.put, callback);
      },
      setShuffle: function(state, options, callback) {
        var params = {
          state
        };
        if (options && "device_id" in options) {
          params.device_id = options.device_id;
        }
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/player/shuffle").withQueryParameters(params).build().execute(HttpManager.put, callback);
      },
      setVolume: function(volumePercent, options, callback) {
        var params = {
          volume_percent: volumePercent
        };
        if (options && "device_id" in options) {
          params.device_id = options.device_id;
        }
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/player/volume").withQueryParameters(params).build().execute(HttpManager.put, callback);
      },
      followUsers: function(userIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/following").withQueryParameters({
          ids: userIds.join(","),
          type: "user"
        }).build().execute(HttpManager.put, callback);
      },
      followArtists: function(artistIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/following").withQueryParameters({
          ids: artistIds.join(","),
          type: "artist"
        }).build().execute(HttpManager.put, callback);
      },
      unfollowUsers: function(userIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/following").withQueryParameters({
          ids: userIds.join(","),
          type: "user"
        }).build().execute(HttpManager.del, callback);
      },
      unfollowArtists: function(artistIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/following").withQueryParameters({
          ids: artistIds.join(","),
          type: "artist"
        }).build().execute(HttpManager.del, callback);
      },
      isFollowingUsers: function(userIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/following/contains").withQueryParameters({
          ids: userIds.join(","),
          type: "user"
        }).build().execute(HttpManager.get, callback);
      },
      getFollowedArtists: function(options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/following").withQueryParameters({
          type: "artist"
        }, options).build().execute(HttpManager.get, callback);
      },
      areFollowingPlaylist: function(userId, playlistId, followerIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/users/" + encodeURIComponent(userId) + "/playlists/" + playlistId + "/followers/contains").withQueryParameters({
          ids: followerIds.join(",")
        }).build().execute(HttpManager.get, callback);
      },
      isFollowingArtists: function(artistIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/following/contains").withQueryParameters({
          ids: artistIds.join(","),
          type: "artist"
        }).build().execute(HttpManager.get, callback);
      },
      getNewReleases: function(options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/browse/new-releases").withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      getFeaturedPlaylists: function(options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/browse/featured-playlists").withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      getCategories: function(options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/browse/categories").withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      getCategory: function(categoryId, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/browse/categories/" + categoryId).withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      getPlaylistsForCategory: function(categoryId, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/browse/categories/" + categoryId + "/playlists").withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      getShow: function(showId, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/shows/" + showId).withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      getShows: function(showIds, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/shows").withQueryParameters({
          ids: showIds.join(",")
        }, options).build().execute(HttpManager.get, callback);
      },
      containsMySavedShows: function(showIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/shows/contains").withQueryParameters({
          ids: showIds.join(",")
        }).build().execute(HttpManager.get, callback);
      },
      removeFromMySavedShows: function(showIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/shows").withHeaders({ "Content-Type": "application/json" }).withBodyParameters(showIds).build().execute(HttpManager.del, callback);
      },
      addToMySavedShows: function(showIds, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/shows").withHeaders({ "Content-Type": "application/json" }).withBodyParameters(showIds).build().execute(HttpManager.put, callback);
      },
      getMySavedShows: function(options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/me/shows").withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      getShowEpisodes: function(showId, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/shows/" + showId + "/episodes").withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      searchShows: function(query, options, callback) {
        return this.search(query, ["show"], options, callback);
      },
      searchEpisodes: function(query, options, callback) {
        return this.search(query, ["episode"], options, callback);
      },
      getEpisode: function(episodeId, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/episodes/" + episodeId).withQueryParameters(options).build().execute(HttpManager.get, callback);
      },
      getEpisodes: function(episodeIds, options, callback) {
        return WebApiRequest.builder(this.getAccessToken()).withPath("/v1/episodes").withQueryParameters({
          ids: episodeIds.join(",")
        }, options).build().execute(HttpManager.get, callback);
      }
    };
    SpotifyWebApi._addMethods = function(methods) {
      for (var i in methods) {
        if (methods.hasOwnProperty(i)) {
          this.prototype[i] = methods[i];
        }
      }
    };
    module.exports = SpotifyWebApi;
  }
});

// node_modules/spotify-web-api-node/src/client.js
var require_client2 = __commonJS({
  "node_modules/spotify-web-api-node/src/client.js"(exports, module) {
    module.exports = require_spotify_web_api();
  }
});

// dep:spotify-web-api-node
var spotify_web_api_node_default = require_client2();
export {
  spotify_web_api_node_default as default
};
//# sourceMappingURL=spotify-web-api-node.js.map
